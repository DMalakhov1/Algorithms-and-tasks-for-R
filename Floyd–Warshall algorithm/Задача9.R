#Создание матрицы смежности графа по задаче №4
NEW_GRAPH <- function(x){
  G <- matrix(data = 0, nrow = x, ncol = x)
  return(G)
}
#Добавление ребра заданного веса 
DOP_REBRO <- function(matrix, i, j, weight){
matrix[i, j] <- weight
matrix[j, i] <- weight
return(matrix)
}
G <- NEW_GRAPH(5)
G <- DOP_REBRO(G, 1, 2, 30)
G <- DOP_REBRO(G, 2, 3, 10)
G <- DOP_REBRO(G, 3, 4, 3)
G <- DOP_REBRO(G, 4, 5, 1)
G <- DOP_REBRO(G, 1, 3, 7)
G <- DOP_REBRO(G, 2, 4, 2)
G <- DOP_REBRO(G, 3, 5, 1)

PINK_FLOYD<- function(G, START, END){
  N <- nrow(G)
  G[G == 0] <- Inf #тут я меняю все нули в матрице G на бесконечность 
  P <- matrix(0, N, N) #Создаю матрицу P, заполненную нулями размера NxN
  
  #Начало основной части 
  
  #Фаза 1. Инициализация
  for(k in 1:N){
    for(i in 1:N){
      for(j in 1:N){
        if(G[i,j] > G[i,k] + G[k,j]){ #Тут мы проверяем является ли путь из вершины "i" в "j" через вершину "k" короче, чем !?известный?! нам ранее 
          G[i,j] <- G[i,k] + G[k,j] #Обновляем матрицу G на новый кратчайший путь 
          P[i,j] <- k #Обновляем матрицу на новую вершину через которую проходит этот путь 
        }
      }
    }
  }
  
  #Фаза 2. Поиск маршрута
  R <- function(P, i, j){ 
    if(P[i,j] == 0){ #проверяем, достигнута ли наша конечная вершина 
      return(list()) #вернем пустой список, если конечная вершина достигнута 
    }else{ #рассмотрим случай, когда мы не достигли конечной вершины 
      k <- P[i,j] #Будем искать новую промежуточную вершину K через матрицу P 
      return(c(R(P, i, k), k, R(P, k, j))) #Рекурсивный вызов R для новых путей, соединенных вершиной K
    }
  }
  #По идее, код можно завершать, тк я сделал все, что есть в меточке, НО, почему-то хочу, чтобы все-таки можно было найти кратчайший путь. 


  
  Distance <- G[START, END]
  path <- R(P, START, END) 
  if(length(path) > 0){ #Если маршрут есть, то добавить начальную и конечную вершины
    path <- c(START, path, END)
  }
  #return(path)
  return(list(Distance = Distance, path = path)) #возвращаем результат
}
PINK_FLOYD(G, 1, 5)